import React, { useState, useMemo } from 'react';
import { useQuery } from '@tanstack/react-query';
import { format, subDays, startOfDay, endOfDay, isWithinInterval } from 'date-fns';
import {
  Box,
  Grid,
  Card,
  CardContent,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  CircularProgress,
  Alert,
  Chip,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  useTheme,
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import {
  Timeline,
  TrendingUp,
  TrendingDown,
  TrendingFlat,
  SportsBasketball,
  SportsFootball,
  SportsBaseball,
  SportsHockey,
  History,
  CheckCircle,
  Cancel,
  RemoveCircle,
} from '@mui/icons-material';
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from 'recharts';
import api from '../services/api';

// ========== Type Definitions ==========
interface HistoryItem {
  id: string;
  date: string;
  prediction: string;
  result: 'correct' | 'incorrect';
  accuracy: number;
  details: string;
  player: string;
  sport: string;
  is_real_data: boolean;
}

interface HistoryResponse {
  success: boolean;
  history: HistoryItem[];
  count: number;
  timestamp: string;
  is_real_data: boolean;
}

interface PlayerTrend {
  player: string;
  sport: string;
  accuracy: number;
  predictions: number;
  correct: number;
  trend: 'up' | 'down' | 'stable';
}

// ========== Sport Config ==========
const SPORTS = [
  { value: 'nba', label: 'NBA', icon: <SportsBasketball />, color: '#1d428a' },
  { value: 'nfl', label: 'NFL', icon: <SportsFootball />, color: '#013369' },
  { value: 'mlb', label: 'MLB', icon: <SportsBaseball />, color: '#e31837' },
  { value: 'nhl', label: 'NHL', icon: <SportsHockey />, color: '#000' },
  { value: 'all', label: 'All Sports', icon: <Timeline />, color: '#757575' },
];

const CHART_COLORS = ['#4caf50', '#f44336', '#ff9800', '#2196f3', '#9c27b0'];
const RESULT_COLORS = {
  correct: '#4caf50',
  incorrect: '#f44336',
};

// ========== Main Component ==========
const HistoricalAnalyticsScreen: React.FC = () => {
  const theme = useTheme();
  const [selectedSport, setSelectedSport] = useState<string>('all');
  const [startDate, setStartDate] = useState<Date>(subDays(new Date(), 30));
  const [endDate, setEndDate] = useState<Date>(new Date());
  const [selectedPlayer, setSelectedPlayer] = useState<string>('');

  // ========== Fetch History Data ==========
  const {
    data: historyData,
    isLoading,
    error,
  } = useQuery<HistoryResponse>({
    queryKey: ['history'],
    queryFn: () => api.get('/api/history').then((res) => res.data),
    staleTime: 5 * 60 * 1000,
  });

  // ========== Filtered & Processed Data ==========
  const filteredHistory = useMemo(() => {
    if (!historyData?.history) return [];

    return historyData.history.filter((item) => {
      const itemDate = new Date(item.date);
      const dateInRange = isWithinInterval(itemDate, {
        start: startOfDay(startDate),
        end: endOfDay(endDate),
      });
      const sportMatch = selectedSport === 'all' || item.sport.toLowerCase() === selectedSport.toLowerCase();
      const playerMatch = !selectedPlayer || item.player === selectedPlayer;
      return dateInRange && sportMatch && playerMatch;
    });
  }, [historyData, startDate, endDate, selectedSport, selectedPlayer]);

  // Group by date for accuracy trend chart
  const accuracyByDate = useMemo(() => {
    const grouped: Record<string, { total: number; correct: number }> = {};
    filteredHistory.forEach((item) => {
      const date = format(new Date(item.date), 'yyyy-MM-dd');
      if (!grouped[date]) grouped[date] = { total: 0, correct: 0 };
      grouped[date].total += 1;
      if (item.result === 'correct') grouped[date].correct += 1;
    });

    return Object.entries(grouped)
      .map(([date, { total, correct }]) => ({
        date,
        accuracy: total > 0 ? (correct / total) * 100 : 0,
        total,
        correct,
      }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }, [filteredHistory]);

  // Overall stats
  const overallStats = useMemo(() => {
    const total = filteredHistory.length;
    const correct = filteredHistory.filter((i) => i.result === 'correct').length;
    const accuracy = total > 0 ? (correct / total) * 100 : 0;
    return { total, correct, incorrect: total - correct, accuracy };
  }, [filteredHistory]);

  // Player performance summary
  const playerStats = useMemo(() => {
    const stats: Record<string, { correct: number; total: number; sport: string }> = {};
    filteredHistory.forEach((item) => {
      if (!stats[item.player]) {
        stats[item.player] = { correct: 0, total: 0, sport: item.sport };
      }
      stats[item.player].total += 1;
      if (item.result === 'correct') stats[item.player].correct += 1;
    });

    return Object.entries(stats)
      .map(([player, data]) => ({
        player,
        sport: data.sport,
        accuracy: data.total > 0 ? (data.correct / data.total) * 100 : 0,
        predictions: data.total,
        correct: data.correct,
        trend: data.correct / data.total > 0.7 ? 'up' : data.correct / data.total < 0.4 ? 'down' : 'stable',
      }))
      .sort((a, b) => b.predictions - a.predictions)
      .slice(0, 10);
  }, [filteredHistory]);

  // Unique players for dropdown
  const playerOptions = useMemo(() => {
    if (!historyData?.history) return [];
    const players = new Set(
      historyData.history
        .filter((i) => selectedSport === 'all' || i.sport.toLowerCase() === selectedSport.toLowerCase())
        .map((i) => i.player)
    );
    return Array.from(players).map((p) => ({ value: p, label: p }));
  }, [historyData, selectedSport]);

  // ========== Loading / Error ==========
  if (isLoading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="80vh">
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box p={3}>
        <Alert severity="error">
          Failed to load historical data. Please try again later.
        </Alert>
      </Box>
    );
  }

  // ========== Render Helpers ==========
  const renderResultIcon = (result: string) => {
    switch (result) {
      case 'correct':
        return <CheckCircle sx={{ color: RESULT_COLORS.correct }} fontSize="small" />;
      case 'incorrect':
        return <Cancel sx={{ color: RESULT_COLORS.incorrect }} fontSize="small" />;
      default:
        return <RemoveCircle sx={{ color: '#ff9800' }} fontSize="small" />;
    }
  };

  const renderTrendIcon = (trend: string) => {
    switch (trend) {
      case 'up':
        return <TrendingUp sx={{ color: '#4caf50' }} fontSize="small" />;
      case 'down':
        return <TrendingDown sx={{ color: '#f44336' }} fontSize="small" />;
      default:
        return <TrendingFlat sx={{ color: '#ff9800' }} fontSize="small" />;
    }
  };

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box p={3}>
        {/* Header */}
        <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
          <Box display="flex" alignItems="center">
            <History sx={{ fontSize: 32, mr: 1, color: theme.palette.primary.main }} />
            <Typography variant="h4" fontWeight={600}>
              Historical Analytics
            </Typography>
          </Box>
          <Chip
            label={historyData?.is_real_data ? 'Real Data' : 'Simulated Data'}
            color={historyData?.is_real_data ? 'success' : 'default'}
            size="small"
          />
        </Box>

        {/* Filters */}
        <Card sx={{ mb: 4 }}>
          <CardContent>
            <Typography variant="h6" gutterBottom>
              Filters
            </Typography>
            <Grid container spacing={3} alignItems="center">
              <Grid item xs={12} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel id="sport-filter-label">Sport</InputLabel>
                  <Select
                    labelId="sport-filter-label"
                    value={selectedSport}
                    label="Sport"
                    onChange={(e) => {
                      setSelectedSport(e.target.value);
                      setSelectedPlayer('');
                    }}
                  >
                    {SPORTS.map((sport) => (
                      <MenuItem key={sport.value} value={sport.value}>
                        <Box display="flex" alignItems="center">
                          {sport.icon}
                          <Typography sx={{ ml: 1 }}>{sport.label}</Typography>
                        </Box>
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={12} md={3}>
                <DatePicker
                  label="Start Date"
                  value={startDate}
                  onChange={(newValue) => newValue && setStartDate(newValue)}
                  slotProps={{ textField: { size: 'small', fullWidth: true } }}
                />
              </Grid>
              <Grid item xs={12} md={3}>
                <DatePicker
                  label="End Date"
                  value={endDate}
                  onChange={(newValue) => newValue && setEndDate(newValue)}
                  slotProps={{ textField: { size: 'small', fullWidth: true } }}
                />
              </Grid>
              <Grid item xs={12} md={2}>
                <FormControl fullWidth size="small">
                  <InputLabel id="player-filter-label">Player</InputLabel>
                  <Select
                    labelId="player-filter-label"
                    value={selectedPlayer}
                    label="Player"
                    onChange={(e) => setSelectedPlayer(e.target.value)}
                  >
                    <MenuItem value="">All Players</MenuItem>
                    {playerOptions.map((opt) => (
                      <MenuItem key={opt.value} value={opt.value}>
                        {opt.label}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={12} md={2}>
                <Typography variant="body2" color="textSecondary">
                  {filteredHistory.length} predictions found
                </Typography>
              </Grid>
            </Grid>
          </CardContent>
        </Card>

        {/* Summary Cards */}
        <Grid container spacing={3} mb={4}>
          <Grid item xs={12} sm={4}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom variant="body2">
                  Total Predictions
                </Typography>
                <Typography variant="h4">{overallStats.total}</Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={4}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom variant="body2">
                  Accuracy
                </Typography>
                <Typography variant="h4" sx={{ color: overallStats.accuracy > 70 ? '#4caf50' : '#ff9800' }}>
                  {overallStats.accuracy.toFixed(1)}%
                </Typography>
                <Typography variant="caption">
                  {overallStats.correct} correct / {overallStats.incorrect} incorrect
                </Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={4}>
            <Card>
              <CardContent>
                <Typography color="textSecondary" gutterBottom variant="body2">
                  Date Range
                </Typography>
                <Typography variant="body1">
                  {format(startDate, 'MMM dd, yyyy')} - {format(endDate, 'MMM dd, yyyy')}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>

        {/* Accuracy Trend Chart */}
        <Card sx={{ mb: 4 }}>
          <CardContent>
            <Typography variant="h6" gutterBottom>
              Prediction Accuracy Over Time
            </Typography>
            {accuracyByDate.length > 0 ? (
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={accuracyByDate}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" tickFormatter={(date) => format(new Date(date), 'MMM dd')} />
                  <YAxis domain={[0, 100]} unit="%" />
                  <Tooltip
                    labelFormatter={(label) => format(new Date(label), 'MMM dd, yyyy')}
                    formatter={(value: number) => [`${value.toFixed(1)}%`, 'Accuracy']}
                  />
                  <Legend />
                  <Line
                    type="monotone"
                    dataKey="accuracy"
                    stroke={theme.palette.primary.main}
                    strokeWidth={2}
                    dot={{ r: 4 }}
                    activeDot={{ r: 6 }}
                  />
                </LineChart>
              </ResponsiveContainer>
            ) : (
              <Box py={4} textAlign="center">
                <Typography color="textSecondary">No data available for selected filters</Typography>
              </Box>
            )}
          </CardContent>
        </Card>

        {/* Player Performance & Recent Predictions */}
        <Grid container spacing={4}>
          {/* Top Players by Accuracy */}
          <Grid item xs={12} md={6}>
            <Card sx={{ height: '100%' }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Player Performance
                </Typography>
                {playerStats.length > 0 ? (
                  <TableContainer component={Paper} variant="outlined">
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell>Player</TableCell>
                          <TableCell align="center">Sport</TableCell>
                          <TableCell align="right">Predictions</TableCell>
                          <TableCell align="right">Accuracy</TableCell>
                          <TableCell align="center">Trend</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {playerStats.map((stat) => (
                          <TableRow key={stat.player}>
                            <TableCell component="th" scope="row">
                              {stat.player}
                            </TableCell>
                            <TableCell align="center">
                              <Chip
                                label={stat.sport}
                                size="small"
                                icon={SPORTS.find((s) => s.value === stat.sport.toLowerCase())?.icon}
                                variant="outlined"
                              />
                            </TableCell>
                            <TableCell align="right">{stat.predictions}</TableCell>
                            <TableCell align="right">
                              <Typography
                                fontWeight={500}
                                color={stat.accuracy > 70 ? 'success.main' : stat.accuracy < 40 ? 'error.main' : 'warning.main'}
                              >
                                {stat.accuracy.toFixed(1)}%
                              </Typography>
                            </TableCell>
                            <TableCell align="center">{renderTrendIcon(stat.trend)}</TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>
                ) : (
                  <Box py={2}>
                    <Typography color="textSecondary">No player data available</Typography>
                  </Box>
                )}
              </CardContent>
            </Card>
          </Grid>

          {/* Recent Predictions */}
          <Grid item xs={12} md={6}>
            <Card sx={{ height: '100%' }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Recent Predictions
                </Typography>
                {filteredHistory.length > 0 ? (
                  <TableContainer component={Paper} variant="outlined" sx={{ maxHeight: 400 }}>
                    <Table size="small" stickyHeader>
                      <TableHead>
                        <TableRow>
                          <TableCell>Date</TableCell>
                          <TableCell>Player</TableCell>
                          <TableCell>Prediction</TableCell>
                          <TableCell align="center">Result</TableCell>
                          <TableCell align="right">Accuracy</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {filteredHistory.slice(0, 10).map((item) => (
                          <TableRow key={item.id}>
                            <TableCell>{format(new Date(item.date), 'MMM dd')}</TableCell>
                            <TableCell>{item.player}</TableCell>
                            <TableCell>{item.prediction}</TableCell>
                            <TableCell align="center">
                              <Box display="flex" alignItems="center" justifyContent="center">
                                {renderResultIcon(item.result)}
                                <Typography variant="caption" sx={{ ml: 0.5 }}>
                                  {item.result}
                                </Typography>
                              </Box>
                            </TableCell>
                            <TableCell align="right">
                              <Chip
                                label={`${item.accuracy}%`}
                                size="small"
                                color={item.accuracy > 80 ? 'success' : item.accuracy > 60 ? 'primary' : 'default'}
                              />
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </TableContainer>
                ) : (
                  <Box py={4} textAlign="center">
                    <Typography color="textSecondary">No predictions found</Typography>
                  </Box>
                )}
              </CardContent>
            </Card>
          </Grid>
        </Grid>

        {/* Footer timestamp */}
        <Box mt={4} display="flex" justifyContent="flex-end">
          <Typography variant="caption" color="textSecondary">
            Last updated: {historyData?.timestamp ? format(new Date(historyData.timestamp), 'MMM dd, yyyy HH:mm') : 'N/A'}
          </Typography>
        </Box>
      </Box>
    </LocalizationProvider>
  );
};

export default HistoricalAnalyticsScreen;
